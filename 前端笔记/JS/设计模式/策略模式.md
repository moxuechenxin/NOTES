### 说明
定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换

### 基本的策略模式 （面向对象风格）
一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体 的算法，并负责具体的计算过程。 第二个部分是环境类 Context，Context 接受客户的请求，随后 把请求委托给某一个策略类。要做到这点，说明 Context 中要维持对某个策略对象的引用。

```js
// 先把每种绩效的计算规则都封装在对应的策略类里面
var performanceS = function(){};
performanceS.prototype.calculate = function( salary ){     
    return salary * 4;
};
var performanceA = function(){};
performanceA.prototype.calculate = function( salary ){     
    return salary * 3;
};
var performanceB = function(){};
performanceB.prototype.calculate = function( salary ){     
    return salary * 2;
};

// 接下来定义奖金类 Bonus:
var Bonus = function(){
    this.salary = null;  // 原始工资
    this.strategy = null;  // 绩效等级对应的策略对象
};

Bonus.prototype.setSalary = function( salary ){  
    this.salary = salary; // 设置员工的原始工资
};

Bonus.prototype.setStrategy = function( strategy ){
    this.strategy = strategy; // 设置员工绩效等级对应的策略对象
};

Bonus.prototype.getBonus = function(){ // 取得奖金数额
    return this.strategy.calculate( this.salary ); // 把计算奖金的操作委托给对应的策略对象
};

var bonus = new Bonus();

bonus.setSalary( 10000 );
bonus.setStrategy( new performanceS() ); // 设置策略对象

console.log( bonus.getBonus() ); // 输出:40000

bonus.setStrategy( new performanceA() ); // 设置策略对象
console.log( bonus.getBonus() ); // 输出:30000
```

### 函数式策略模式
```js
var strategies = {
    "S": function( salary ){
        return salary * 4;
    },
    "A": function( salary ){
        return salary * 3;
    },
    "B": function( salary ){
        return salary * 2;
    }
}
var calculateBonus = function( level, salary ){
    return strategies[ level ]( salary );
};
console.log( calculateBonus( 'S', 20000 ) ); // 输出:80000
console.log( calculateBonus( 'A', 10000 ) ); // 输出:30000

```

### 缺点
- 使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在 Context 中要好
- 要使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点， 这样才能选择一个合适的 strategy
