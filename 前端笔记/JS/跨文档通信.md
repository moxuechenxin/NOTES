## 同域通信
### 1. iframe
通过`iframeObj.contentWindow`或`window.frames[index/name]`访问`iframe`中的`window`对象

**注意**：  
包含iframe的文档中：
- `top`：顶级文档window对象
- `parent`：父级文档window对象
- `window`：当前文档window对象

### 2.window.open()
返回被打开窗口的window对象  

**语法**：`window.open(url)` 

**注意**：
一些浏览器默认禁止新开跨域窗口，可通过先打开空的新窗口，再修改新窗口的地址
```js
var newWin = window.open();
newWin.location.href = 'https://www.baidu.com';
```

## 跨域通信
### 1. window.postMessage()
通常情况下，不同页面上的脚本，当且仅当这些页面URL的协议、端口、域名相同的时候才可以进行相互访问。window.postMessage() 方法可以安全的进行跨域通信。

**语法**：`otherWindow.postMessage(message, targetOrigin, [transfer])`

**参数**：
- **otherWindow**：其他窗口的一个引用。（比如`iframe`的`contentWindow`属性、执行`window.open`返回的窗口对象、或者是命名过或数值索引的`window.frames`）
- **message**：将要发送到其他 window的数据。（它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。低版本浏览器`message`必须是一个字符串）
- **targetOrigin**：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。（在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口）
- **transfer**：可选。一串和message 同时传递的 `Transferable` 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权

#### message事件
监听另一个window对象用`postMessage`发送的message
```js
window.addEventListener("message", receiveMessage, false);

function receiveMessage(event)
{
  // For Chrome, the origin property is in the event.originalEvent
  // object.
  var origin = event.origin || event.originalEvent.origin; 
  if (origin !== "http://example.org:8080")
    return;

  // ...
}
```
事件监听函数的`event`对象有以下属性:
- **data**：从其他 window 中传递过来的`message`
- **origin**：调用`postMessage`时消息发送方窗口的`origin`。（ 这个字符串由 `协议`、`://`、`域名`、`: 端口号`拼接而成。例如 `https://example.org (implying port 443)`、`http://example.net (implying port 80)`、`http://example.com:8080`。请注意，这个origin不能保证是该窗口的当前或未来origin，因为`postMessage`被调用后可能被导航到不同的位置）
- **source**：对发送消息的窗口对象的引用。（您可以使用此来在具有不同origin的两个窗口之间建立双向通信）


**参考**
- [window.postMessage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)