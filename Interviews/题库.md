## 知识点
- 页面布局
- css盒模型
  - BFC
- DOM事件
- HTTP协议
- 面向对象
- 原型链
- 通信
- 安全
- 算法

## 页面布局
#### 1. 假设高度已知，请写出三栏布局，其中左右栏宽度为300px，中间自适应

> 方案一：浮动float

```html
<style>
  .left {
    float: left;
    width: 300px;
  }
  .right {
    float: right;
    width: 300px;
  }
  .center {
    overflow: hidden;  /* 生成BFC */
  }
</style>

<div class="wrap clr">
  <div class="left"></div>
  <div class="right"></div>
  <div class="center"></div>
</div>
```

> 方案二：绝对定位postion: absolute

```html
<style>
  .wrap {
    postion: relative;
  }
  .wrap > div{
    postion: absolute;
    top: 0;
  }
  .left {
    left: 0;
    width: 300px;
  }
  .center {
    left: 300px;
    right: 300px;
  }
  .right {
    right: 0;
    width: 300px;
  }
</style>

<div class="wrap">
  <div class="left"></div>
  <div class="center"></div>
  <div class="right"></div>
</div>
```

> 方案三：flexbox

```html
<style>
  .wrap {
    display: flex;
  }
  .left {
    width: 300px;
    flex: none;
  }
  .center {
    flex: 1;
  }
  .right {
    width: 300px;
    flex: none;
  }
</style>

<div class="wrap">
  <div class="left"></div>
  <div class="center"></div>
  <div class="right"></div>
</div>
```

> 方案四：table-cell

```html
<style>
  .wrap {
    width: 100%;
    display: table;
  }
  .wrap > div {
    display: table-cell;
  }
  .left {
    width: 300px;
  }
  .center {
  }
  .right {
    width: 300px;
  }
</style>

<div class="wrap">
  <div class="left"></div>
  <div class="center"></div>
  <div class="right"></div>
</div>
```

> 方案五：网格布局grid

```html
<style>
  .wrap {
    display: grid;
    width: 100%;
    grid-template-rows: 100px; /* 高度 */
    grid-template-columns: 300px auto 300px;
  }
</style>

<div class="wrap">
  <div class="left"></div>
  <div class="center"></div>
  <div class="right"></div>
</div>
```

## DOM事件
- 基本概念：DOM事件的级别
- DOM事件模型：事件冒泡、事件捕获
- DOM事件流
- DOM事件捕获的具体流程
- Event对象的常见应用
- 自定义事件

#### DOM事件级别

```js
// DOM0
element.onclick = function() {}

// DOM2
element.addEventListener('click', function() {}, false)

// DOM3
element.addEventListener('click', function() {}, false)
```

#### 事件流
流程如下：
1. 捕获
2. 目标阶段
3. 冒泡

#### DOM事件捕获的具体流程
window -> document -> html (`document.documentElement`) -> body (`document.body`) -> ... -> element

#### Event对象常见应用

```js
// 阻止默认事件
event.preventDefault()
// 阻止冒泡
event.stopPropagation()
// 阻止冒泡，并阻止执行该事件绑定的其他事件处理函数（用于多个事件处理函数的情况）
event.stopImmediatePropagation()
// 当事件遍历DOM时，标识事件的当前目标。在事件处理函数中等同于this
event.currentTarget
// 一个触发事件的对象的引用
event.target
```

#### 自定义事件（CustomEvent）

> 简易版本（注意与`模拟事件（代码触发事件）`区别）
```js
// 与CustomEvent区别参考MDN
const event = new Event('custome-name')
// 绑定事件处理函数
element.addEventListener('custome-name', handler)
// 触发自定义事件
element.dispatchEvent(event)
```

## HTTP协议
- HTTP协议的主要特点
- HTTP报文的组成部分
- HTTP方法
- POST和GET的区别
- HTTP状态码
- 什么是持久连接
- 什么是管线化

#### HTTP协议的主要特点
- 简单快速：每个资源URI固定
- 灵活：通过一个HTTP协议，可以完成不同数据类型的传输
- 无连接：连接一次即断开，不会保持连接
- 无状态：单从HTTP协议上不能区别两次连接者的身份

#### HTTP报文的组成部分
- 请求报文
  - 请求行：HTTP方法、请求地址、HTTP协议以及版本
  - 请求头：一些`key-value`值来告诉服务端要哪些内容，注意是什么类型
  - 空行：告诉服务端请求体的开始
  - 请求体

- 响应报文
  - 状态行
  - 响应头
  - 空行
  - 响应体

#### HTTP方法
- GET：获取资源
- POST：传输资源
- PUT：更新资源
- DELETEL：删除资源
- HEAD：获取报文首部

#### POST和GET的区别
- GET在浏览器回退时是无害的，而POST会再次提交请求
- GET产生的URL地址可以被收藏，而POST不可以
- GET请求会被浏览器主动缓存，而POST不会，除非手动设置
- GET请求只能进行url编码，而POST支持多种编码方式
- GET请求参数会被完整保留在浏览器历史记录中，而POST中的参数不会被保留
- GET请求在URL中传送的参数是有长度限制的，而POST没有限制（不太准备：应该为url地址有长度限制，无论什么请求方法）
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息
- GET参数通过URL传递，POST放在Request body中

#### HTTP状态码
- 1XX：指示信息 - 表示请求已接收，继续处理
- 2XX：成功 - 表示请求已被成功接收
- 3XX：重定向 - 要完成请求必须进行更进一步的操作
- 4XX：客户端错误 - 请求有语法错误或请求无法实现
- 5XX：服务端错误 - 服务器未能实现合法的请求

状态码 | 状态标识 | 含义
---|---|---
200 | OK | 客户端请求成功
206 | Partial Content | 客户端发送了一个带有Range头的GET请求，服务器完成了它
301 | Moved Permanently | 所请求的页面已经转移到新的url
302 | Found | 所请求的页面已经临时转移到新的url
304 | Not Modified | 协商缓存中服务器返回该状态码，表示缓存可以继续使用
400 | Bad Request | 客户端请求有语法错误，不能被服务器所理解
401 | Unauthorized | 请求未经授权，这个状态码必须和`WWW-Authenticate`报头域一起使用
403 | Forbidden | 对请求资源的访问被禁止
404 | Not Found | 请求资源不存在
500 | Internal Server Error | 服务器发生不可预期的错误，原来缓存的文档还可以继续使用
503 | Server Unavailable | 请求未完成，服务器临时过载或当机，一段时间后可能恢复正常

#### HTTP持久连接
HTTP协议采用`请求-应答`模式，当使用普通模式，即非`Keep-Alive`模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）

当使用`Keep-Alive`模式（又称持久连接、连接重用，HTTP1.1以上支持）时，`Keep-Alive`功能使客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，`Keep-Alive`功能避免了建立或者重新建立连接

#### 管线化
在使用持久连接的情况下，某个连接上消息的传递类似于：  
请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3

管线化：某个连接上的消息变成类似这样：  
请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3 

**管线化特点**：
- 管线化机制通过持连接完成，仅HTTP/1.1及以上支持该技术
- 只有GET和HEAD请求可以进行管线化，而POST则有所限制
- 初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议
- 管线化不会影响响应到来的顺序
- HTTP/1.1要求服务端支持管线化，但并不要求服务器端也对响应进行管线化处理，只要求对于管线化的请求不失败即可
- 由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此Chrome和Firefox等默认并未开启管线化支持

## vue/react
#### 1. 父组件和子组件之间怎么传递数据的？

##### 父组件向子组件传递
1. 父组件向子组件传递prop
2. (vue) vuex等; (react) redux等

##### 子组件向父组件传递
1. 父组件向子组件传递函数类型的prop，子组件调用该函数，传入要传递的数据作为参数
2. (vue) 父组件监听自定义事件，子组件触发该自定义事件
3. (vue) 通过prop的sync修饰符实现数据双向绑定

#### 2. 了解过vue和react底层实现数据驱动视图响应的原理吗？能实现一个vue的$watch功能吗（监听data数据变化触发绑定事件）？

#### 3. 讲一下对闭包的理解，最好举个实例

#### 4. 谈谈面向对象（原型）

#### 5. 谈谈网页保持登陆状态的做法，包括和后端的交互

#### 6. 网页自适应和响应式有什么区别？怎么实现？

#### 7. 一个选项切换的时候要发送一条数据，然后页面根据返回的数据重新渲染，每次请求来回所花的时间是随机的，怎么做到页面渲染的只是最后一条请求的数据？

#### 8. 前端存储有哪些方式？实际开发中你用到了哪些？


## 编码题
#### 1. 实现一个事件处理系统（包含监听事件、触发事件、解绑事件）

备注：观察者设计模式

#### 2. 写出下列列代码执行后，console的打印顺序，并解释一下原因
```js
setTimeout(function() {
  console.log(1)
}, 0);
new Promise(function executor(resolve) {
  console.log(2);
  for( var i=0 ; i<10000 ; i++ ) {
    i == 9999 && resolve();
  }
  console.log(3);
}).then(function() {
  console.log(4);
});
console.log(5);
```
答案：`2、3、5、4、1`

## 开放题
#### 1. 就目前你所掌握的技能和知识，列举一些比较深刻的（或者说你觉得优于别人的）？

