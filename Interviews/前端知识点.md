## 知识点
- 页面布局
- css盒模型
  - BFC
- DOM事件
- HTTP协议
- 面向对象
- 原型链
- 通信
- 安全
- 算法

## 页面布局
#### 1. 假设高度已知，请写出三栏布局，其中左右栏宽度为300px，中间自适应

> 方案一：浮动float

```html
<style>
  .left {
    float: left;
    width: 300px;
  }
  .right {
    float: right;
    width: 300px;
  }
  .center {
    overflow: hidden;  /* 生成BFC */
  }
</style>

<div class="wrap clr">
  <div class="left"></div>
  <div class="right"></div>
  <div class="center"></div>
</div>
```

> 方案二：绝对定位postion: absolute

```html
<style>
  .wrap {
    postion: relative;
  }
  .wrap > div{
    postion: absolute;
    top: 0;
  }
  .left {
    left: 0;
    width: 300px;
  }
  .center {
    left: 300px;
    right: 300px;
  }
  .right {
    right: 0;
    width: 300px;
  }
</style>

<div class="wrap">
  <div class="left"></div>
  <div class="center"></div>
  <div class="right"></div>
</div>
```

> 方案三：flexbox

```html
<style>
  .wrap {
    display: flex;
  }
  .left {
    width: 300px;
    flex: none;
  }
  .center {
    flex: 1;
  }
  .right {
    width: 300px;
    flex: none;
  }
</style>

<div class="wrap">
  <div class="left"></div>
  <div class="center"></div>
  <div class="right"></div>
</div>
```

> 方案四：table-cell

```html
<style>
  .wrap {
    width: 100%;
    display: table;
  }
  .wrap > div {
    display: table-cell;
  }
  .left {
    width: 300px;
  }
  .center {
  }
  .right {
    width: 300px;
  }
</style>

<div class="wrap">
  <div class="left"></div>
  <div class="center"></div>
  <div class="right"></div>
</div>
```

> 方案五：网格布局grid

```html
<style>
  .wrap {
    display: grid;
    width: 100%;
    grid-template-rows: 100px; /* 高度 */
    grid-template-columns: 300px auto 300px;
  }
</style>

<div class="wrap">
  <div class="left"></div>
  <div class="center"></div>
  <div class="right"></div>
</div>
```

## DOM事件
- 基本概念：DOM事件的级别
- DOM事件模型：事件冒泡、事件捕获
- DOM事件流
- DOM事件捕获的具体流程
- Event对象的常见应用
- 自定义事件

#### DOM事件级别

```js
// DOM0
element.onclick = function() {}

// DOM2
element.addEventListener('click', function() {}, false)

// DOM3
element.addEventListener('click', function() {}, false)
```

#### 事件流
流程如下：
1. 捕获
2. 目标阶段
3. 冒泡

#### DOM事件捕获的具体流程
window -> document -> html (`document.documentElement`) -> body (`document.body`) -> ... -> element

#### Event对象常见应用

```js
// 阻止默认事件
event.preventDefault()
// 阻止冒泡
event.stopPropagation()
// 阻止冒泡，并阻止执行该事件绑定的其他事件处理函数（用于多个事件处理函数的情况）
event.stopImmediatePropagation()
// 当事件遍历DOM时，标识事件的当前目标。在事件处理函数中等同于this
event.currentTarget
// 一个触发事件的对象的引用
event.target
```

#### 自定义事件（CustomEvent）

> 简易版本（注意与`模拟事件（代码触发事件）`区别）
```js
// 与CustomEvent区别参考MDN
const event = new Event('custome-name')
// 绑定事件处理函数
element.addEventListener('custome-name', handler)
// 触发自定义事件
element.dispatchEvent(event)
```

## HTTP协议
- HTTP协议的主要特点
- HTTP报文的组成部分
- HTTP方法
- POST和GET的区别
- HTTP状态码
- 什么是持久连接
- 什么是管线化

#### HTTP协议的主要特点
- 简单快速：每个资源URI固定
- 灵活：通过一个HTTP协议，可以完成不同数据类型的传输
- 无连接：连接一次即断开，不会保持连接
- 无状态：单从HTTP协议上不能区别两次连接者的身份

#### HTTP报文的组成部分
- 请求报文
  - 请求行：HTTP方法、请求地址、HTTP协议以及版本
  - 请求头：一些`key-value`值来告诉服务端要哪些内容，注意是什么类型
  - 空行：告诉服务端请求体的开始
  - 请求体

- 响应报文
  - 状态行
  - 响应头
  - 空行
  - 响应体

#### HTTP方法
- GET：获取资源
- POST：传输资源
- PUT：更新资源
- DELETEL：删除资源
- HEAD：获取报文首部

#### POST和GET的区别
- GET在浏览器回退时是无害的，而POST会再次提交请求
- GET产生的URL地址可以被收藏，而POST不可以
- GET请求会被浏览器主动缓存，而POST不会，除非手动设置
- GET请求只能进行url编码，而POST支持多种编码方式
- GET请求参数会被完整保留在浏览器历史记录中，而POST中的参数不会被保留
- GET请求在URL中传送的参数是有长度限制的，而POST没有限制（不太准备：应该为url地址有长度限制，无论什么请求方法）
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息
- GET参数通过URL传递，POST放在Request body中

#### HTTP状态码
- 1XX：指示信息 - 表示请求已接收，继续处理
- 2XX：成功 - 表示请求已被成功接收
- 3XX：重定向 - 要完成请求必须进行更进一步的操作
- 4XX：客户端错误 - 请求有语法错误或请求无法实现
- 5XX：服务端错误 - 服务器未能实现合法的请求

状态码 | 状态标识 | 含义
---|---|---
200 | OK | 客户端请求成功
206 | Partial Content | 客户端发送了一个带有Range头的GET请求，服务器完成了它
301 | Moved Permanently | 所请求的页面已经转移到新的url
302 | Found | 所请求的页面已经临时转移到新的url
304 | Not Modified | 协商缓存中服务器返回该状态码，表示缓存可以继续使用
400 | Bad Request | 客户端请求有语法错误，不能被服务器所理解
401 | Unauthorized | 请求未经授权，这个状态码必须和`WWW-Authenticate`报头域一起使用
403 | Forbidden | 对请求资源的访问被禁止
404 | Not Found | 请求资源不存在
500 | Internal Server Error | 服务器发生不可预期的错误，原来缓存的文档还可以继续使用
503 | Server Unavailable | 请求未完成，服务器临时过载或当机，一段时间后可能恢复正常

#### HTTP持久连接
HTTP协议采用`请求-应答`模式，当使用普通模式，即非`Keep-Alive`模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）

当使用`Keep-Alive`模式（又称持久连接、连接重用，HTTP1.1以上支持）时，`Keep-Alive`功能使客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，`Keep-Alive`功能避免了建立或者重新建立连接

#### 管线化
在使用持久连接的情况下，某个连接上消息的传递类似于：  
请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3

管线化：某个连接上的消息变成类似这样：  
请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3 

**管线化特点**：
- 管线化机制通过持连接完成，仅HTTP/1.1及以上支持该技术
- 只有GET和HEAD请求可以进行管线化，而POST则有所限制
- 初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议
- 管线化不会影响响应到来的顺序
- HTTP/1.1要求服务端支持管线化，但并不要求服务器端也对响应进行管线化处理，只要求对于管线化的请求不失败即可
- 由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此Chrome和Firefox等默认并未开启管线化支持

## 原型链
- 创建对象有几种方法
- 原型、构造函数、实例、原型链
- instanceof的原理
- new运算符

#### 创建对象的方法
> 方法一：对象字面量

```js
const obj1 = {
  name: 'obj1'
}
// 或通过Object构造函数创建
const obj1 = new Object({
  name: 'obj1'
})
```

> 方法二：构造函数

```js
const M = function() {
  this.name = 'obj2'
}
const obj2 = new M()
```

> 方法三：Object.create

`Object.create(proto, [ properties ])`：创建一个拥有指定原型和若干个指定属性的对象

```js
const P = {
  name: 'obj3'
}
const obj3 = Object.create(P)
```

#### 原型、构造函数、实例、原型链
![原型链示意图](/.assets/images/prototype-chain.jpg)

#### instanceof
```bash
<obj> instanceof <Fn>
```
判断`obj`是否是`Fn`的实例（判断`Fn.prototype` 是否存在于实例`obj` 的原型链上）

#### new运算符
执行`new Fn()`底层的步骤：
1. 一个新对象被创建（继承自Fn.prototype）
2. 构造函数Fn被执行，相应的参数会被传入，同时this会被指定为这个新实例（在不传递参数的情况下，new Fn等同于new Fn()）
3. 如果构造函数返回一个对象（而不是基本类型），那么这个对象会取代整个new出来的结果。如果没有返回对象，那么new出来的结果为this（指向实例）

## 面向对象
- 类与实例
  - 类的声明
  - 生成实例
- 类与继承
  - 如何实现继承
  - 继承的几种方式

#### 继承
> 方案一：借助构造函数实现继承

```js
function Parent() {
  this.name = 'parent'
  this.arr = [1, 2]
}
Parent.prototype.say = function() {
  console.log('hello')
}
function Child() {
  Parent.call(this)  // 关键
  this.type = 'child'
}
```
缺点：无法继承原型对象上的属性和方法


> 方案二：借助原型链实现

```js
function Parent() {
  this.name = 'parent'
  this.arr = [1, 2]
}
Parent.prototype.say = function() {
  console.log('hello')
}
function Child() {
  this.type = 'child'
}
Child.prototype = new Parent() // constructor已变为Parent
```
缺点：原型上的属性和方法是对所有实例公用的，当属性为引用类型时，其中一个实例修改该属性值时（譬如push数组），其他实例取到的值也变化了（因为指向的是同一个对象）

> 方案三：组合方式（构造函数 + 原型链）

```js
function Parent() {
  this.name = 'parent'
  this.arr = [1, 2]
}
Parent.prototype.say = function() {
  console.log('hello')
}
function Child() {
  Parent.call(this)
  this.type = 'child'
}
Child.prototype = new Parent() // constructor已变为Parent

/* 优化 */
function Parent() {
  this.name = 'parent'
  this.arr = [1, 2]
}
Parent.prototype.say = function() {
  console.log('hello')
}
function Child() {
  Parent.call(this)
  this.type = 'child'
}
Child.prototype = Parent.prototype // constructor已变为Parent

const child = new Child()
console.log(child instanceof Child) // true
console.log(child.constructor) // Parent() {...}

/* 再优化 */
function Parent() {
  this.name = 'parent'
  this.arr = [1, 2]
}
Parent.prototype.say = function() {
  console.log('hello')
}
function Child() {
  Parent.call(this)
  this.type = 'child'
}
Child.prototype = Object.create(Parent.prototype)
Child.prototype.construtor = Child
```
缺点：